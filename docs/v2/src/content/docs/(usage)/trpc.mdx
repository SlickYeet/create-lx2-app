---
title: tRPC
description: End-to-end typesafe APIs made easy
links:
  {
    docs: https://trpc.io/docs,
    repo: https://github.com/trpc/trpc,
    community: https://trpc.io/discord,
  }
---

[tRPC](https://trpc.io/) allows you to easily build & consume fully typesafe APIs without schemas or code generation. It leverages TypeScript's inference to provide end-to-end type safety between your client and server.

## Client Usage

The tRPC client is available in both Client and Server Components in Next.js. The API is exported from `@/lib/api/client` for Client Components and `@/lib/api/server` for Server Components.

**Client Components:**

```tsx title="src/components/greeting.tsx" showLineNumbers
"use client"

import { api } from "@/lib/api/client"

export function Greeting() {
  const [greeting] = api.post.greeting.useSuspenseQuery({
    text: "from tRPC",
  })

  return (
    <div className="flex flex-col items-start justify-center gap-2">
      <p className="text-xl font-medium">{greeting}</p>
    </div>
  )
}
```

**Server Components:**

```tsx title="src/app/page.tsx" showLineNumbers
import { api, HydrateClient } from "@/lib/api/server"

export default async function Home() {
  const greeting = await api.post.greeting({
    text: "from tRPC",
  })

  return (
    <HydrateClient>
      <main>
        <h1>{greeting}</h1>
      </main>
    </HydrateClient>
  )
}
```

<Callout type="info">
  Server Components use the `api` export, which is a server-side caller.
  `HydrateClient` is used to hydrate the client-side cache with data fetched on
  the server.
</Callout>

## Creating Procedures

Procedures are the functions you can call from your client. They are defined in routers, which are collections of related procedures.

**Query Procedure:**

Queries are used to fetch data. They should not have side effects.

```ts title="src/server/api/routers/post.ts" showLineNumbers
import z from "zod"

import { createTRPCRouter, publicProcedure } from "@/server/api/init"

export const postRouter = createTRPCRouter({
  greeting: publicProcedure
    .input(
      z.object({
        text: z.string(),
      })
    )
    .query(({ input }) => {
      return `Hello ${input.text}`
    }),
})
```

**Mutation Procedure:**

Mutations are used to modify data. They should have side effects.

```ts title="src/server/api/routers/post.ts" showLineNumbers
import z from "zod"

import { createTRPCRouter, publicProcedure } from "@/server/api/init"

export const postRouter = createTRPCRouter({
  create: publicProcedure
    .input(
      z.object({
        name: z.string().min(1),
      })
    )
    .mutation(async ({ input }) => {
      // Perform database operation
      const post = await db.post.create({
        data: { name: input.name },
      })
      return post
    }),
})
```

<Callout type="info">
  tRPC uses [Zod](https://zod.dev/) for input validation. All inputs are
  validated against the schema you define.
</Callout>

## Context

The context is an object that is available in all procedures. It contains information about the request, such as headers, session data, and database instances.

**Accessing Context:**

```ts title="src/server/api/routers/post.ts" showLineNumbers
import { createTRPCRouter, publicProcedure } from "@/server/api/init"

export const postRouter = createTRPCRouter({
  getLatest: publicProcedure.query(async ({ ctx }) => {
    // Access database from context
    const post = await ctx.db.post.findFirst({
      orderBy: { createdAt: "desc" },
    })
    return post
  }),
})
```

**Modifying Context:**

The context is defined in `src/server/api/init.ts`. You can add additional properties to the context by modifying the `createTRPCContext` function.

```ts title="src/server/api/init.ts" showLineNumbers
export async function createTRPCContext(opts: { headers: Headers }) {
  const session = await auth()

  return {
    ...opts,
    session,
    db,
  }
}
```

<Callout type="warning" title="Database Context">
  When using Prisma or Drizzle, the database instance is automatically added to
  the context as `ctx.db`.
</Callout>

## Middleware

Middleware allows you to add logic that runs before your procedures. Common use cases include authentication, logging, and rate limiting.

**Creating Middleware:**

```ts title="src/server/api/init.ts" showLineNumbers
const enforceUserIsAuthed = t.middleware(async ({ ctx, next }) => {
  if (!ctx.session?.user) {
    throw new TRPCError({ code: "UNAUTHORIZED" })
  }
  return next({
    ctx: {
      // infers the `session` as non-nullable
      session: { ...ctx.session, user: ctx.session.user },
    },
  })
})
```

**Using Middleware:**

```ts title="src/server/api/init.ts" showLineNumbers
export const protectedProcedure = t.procedure
  .use(timingMiddleware)
  .use(enforceUserIsAuthed)
```

**Protected Procedure Example:**

```ts title="src/server/api/routers/post.ts" showLineNumbers
import { createTRPCRouter, protectedProcedure } from "@/server/api/init"

export const postRouter = createTRPCRouter({
  create: protectedProcedure
    .input(z.object({ name: z.string().min(1) }))
    .mutation(async ({ ctx, input }) => {
      // ctx.session.user is guaranteed to exist
      const post = await ctx.db.post.create({
        data: {
          name: input.name,
          userId: ctx.session.user.id,
        },
      })
      return post
    }),
})
```

## Error Handling

tRPC provides built-in error handling with specific error codes for different scenarios.

**Throwing Errors:**

```ts title="src/server/api/routers/post.ts" showLineNumbers
import { TRPCError } from "@trpc/server"
import { createTRPCRouter, publicProcedure } from "@/server/api/init"

export const postRouter = createTRPCRouter({
  getById: publicProcedure
    .input(z.object({ id: z.number() }))
    .query(async ({ ctx, input }) => {
      const post = await ctx.db.post.findUnique({
        where: { id: input.id },
      })

      if (!post) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Post not found",
        })
      }

      return post
    }),
})
```

**Handling Errors on Client:**

```tsx title="src/components/post.tsx" showLineNumbers
"use client"

import { api } from "@/lib/api/client"

export function Post({ id }: { id: number }) {
  const { data, error, isLoading } = api.post.getById.useQuery({ id })

  if (isLoading) return <div>Loading...</div>
  if (error) return <div>Error: {error.message}</div>

  return <div>{data.name}</div>
}
```

## Type Inference

tRPC provides type helpers to infer types from your router.

**Input Types:**

```ts title="src/components/create-post.tsx" showLineNumbers
import { type RouterInputs } from "@/lib/api/client"

type CreatePostInput = RouterInputs["post"]["create"]
// { name: string }
```

**Output Types:**

```ts title="src/components/post-list.tsx" showLineNumbers
import { type RouterOutputs } from "@/lib/api/client"

type Post = RouterOutputs["post"]["getLatest"]
```

## React Query Integration

tRPC in Lx2 applications uses React Query under the hood, giving you access to powerful features like caching, refetching, and optimistic updates.

**Mutations with Optimistic Updates:**

```tsx title="src/components/create-post-form.tsx" showLineNumbers
"use client"

import { api } from "@/lib/api/client"

export function CreatePostForm() {
  const utils = api.useUtils()

  const createPost = api.post.create.useMutation({
    onSuccess: async () => {
      // Invalidate and refetch
      await utils.post.getLatest.invalidate()
    },
  })

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault()
        const formData = new FormData(e.currentTarget)
        createPost.mutate({
          name: formData.get("name") as string,
        })
      }}
    >
      <input name="name" />
      <button type="submit" disabled={createPost.isPending}>
        Create
      </button>
    </form>
  )
}
```

**Manual Cache Updates:**

```tsx title="src/components/create-post-form.tsx" showLineNumbers
const createPost = api.post.create.useMutation({
  onMutate: async (newPost) => {
    // Cancel outgoing refetches
    await utils.post.getLatest.cancel()

    // Snapshot the previous value
    const previousPost = utils.post.getLatest.getData()

    // Optimistically update to the new value
    utils.post.getLatest.setData(undefined, newPost)

    return { previousPost }
  },
  onError: (err, newPost, context) => {
    // Rollback on error
    utils.post.getLatest.setData(undefined, context?.previousPost)
  },
})
```

## Routers

Routers organize your procedures into logical groups. You can create multiple routers and merge them in the root router.

**Creating a Router:**

```ts title="src/server/api/routers/user.ts" showLineNumbers
import { createTRPCRouter, publicProcedure } from "@/server/api/init"

export const userRouter = createTRPCRouter({
  getById: publicProcedure
    .input(z.object({ id: z.string() }))
    .query(async ({ ctx, input }) => {
      return await ctx.db.user.findUnique({
        where: { id: input.id },
      })
    }),
})
```

**Merging Routers:**

```ts title="src/server/api/root.ts" showLineNumbers
import { createCallerFactory, createTRPCRouter } from "@/server/api/init"
import { postRouter } from "@/server/api/routers/post"
import { userRouter } from "@/server/api/routers/user"

export const appRouter = createTRPCRouter({
  post: postRouter,
  user: userRouter,
})

export type AppRouter = typeof appRouter

export const createCaller = createCallerFactory(appRouter)
```

## Subscriptions

tRPC supports real-time subscriptions using WebSockets. This is useful for features like live updates, chat applications, and notifications.

<Callout type="warning">
  Subscriptions require additional setup with a WebSocket server. The default
  Lx2 setup uses HTTP and does not include subscriptions out of the box.
</Callout>

For more information on subscriptions, see the [tRPC Subscriptions documentation](https://trpc.io/docs/subscriptions).

## Server-Side Calls

You can call tRPC procedures directly from server-side code without going through HTTP.

**Direct Server Calls:**

```ts title="src/app/api/cron/route.ts" showLineNumbers
import { createCaller } from "@/server/api/root"
import { createTRPCContext } from "@/server/api/init"

export async function GET() {
  const ctx = await createTRPCContext({ headers: new Headers() })
  const caller = createCaller(() => ctx)

  const posts = await caller.post.getLatest()

  return Response.json({ posts })
}
```

## Useful Resources

This is a brief overview of tRPC. For more detailed information, please refer to the official tRPC documentation:

| Resource                                                           | Description                      |
| ------------------------------------------------------------------ | -------------------------------- |
| [tRPC Documentation](https://trpc.io/docs)                         | The official tRPC documentation  |
| [tRPC Quickstart](https://trpc.io/docs/quickstart)                | Getting started guide            |
| [tRPC Error Handling](https://trpc.io/docs/server/error-handling) | Error handling guide             |
| [tRPC Procedures](https://trpc.io/docs/server/procedures)         | Creating procedures              |
| [tRPC Context](https://trpc.io/docs/server/context)               | Context guide                    |
| [tRPC Middleware](https://trpc.io/docs/server/middlewares)        | Middleware guide                 |
| [React Query](https://tanstack.com/query/latest)                  | React Query documentation        |
